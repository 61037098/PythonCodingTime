2.6 线程池与进程池的创建
========================

--------------

   **友情提醒**\ ：
   本系列所有的代码均在Python3下编写。Python2中可能有所差异。

1. 线程池的创建
---------------

使用内置模块
~~~~~~~~~~~~

在使用多线程处理任务时也不是线程越多越好，由于在切换线程的时候，需要切换上下文环境，依然会造成cpu的大量开销。为解决这个问题，线程池的概念被提出来了。预先创建好一个合理数量的线程池，让过来的任务立刻能够使用，就形成了线程池。

在Python3中，创建线程池是通过\ ``concurrent.futures``\ 函数库中的\ ``ThreadPoolExecutor``\ 类来实现的。

.. code:: python

   import time
   import threading
   from concurrent.futures import ThreadPoolExecutor

   def target():
       for i in range(5):
           print('running thread-{}:{}'.format(threading.get_ident(), i))
           time.sleep(1)
           
   # 创建一个最大容纳数量为5的线程池
   pool = ThreadPoolExecutor(5) 

   for i in range(10):
       # 往线程池上塞任务
       pool.submit(target)

创建线程池还可以使用更优雅的方式，就是使用上下文管理器

.. code:: python

   with ThreadPoolExecutor(5) as pool:
       for i in range(100):
           pool.submit(target) 

直接运行代码，从输出可以看出，前面我们设置线程池最大线程数，会保证“同时”仅有五个线程在工作。

.. code:: python

   running thread-123145483767808:0
   running thread-123145489022976:0
   running thread-123145494278144:0
   running thread-123145499533312:0
   running thread-123145504788480:0
   running thread-123145483767808:1
   running thread-123145489022976:1
   running thread-123145499533312:1
   running thread-123145494278144:1
   running thread-123145504788480:1
   running thread-123145489022976:2
   running thread-123145499533312:2
   running thread-123145483767808:2
   running thread-123145504788480:2
   running thread-123145494278144:2
   ....

自定义线程池
~~~~~~~~~~~~

除了使用上述第三方模块的方法之外，我们还可以自己结合前面所学的消息队列来自定义线程池。

这里我们就使用queue来实现一个上面同样效果的例子，大家感受一下。

.. code:: python

   import time
   import threading
   from queue import Queue

   def target(queue):
       while True:
           task = queue.get()
           if task == "stop":
               queue.task_done()
               break

           task()
           queue.task_done()

   def do_task():
       for i in range(5):
           print('running thread-{}:{}'.format(threading.get_ident(), i))
           time.sleep(1)


   class MyQueue(Queue):
       def close(self):
           for i in range(self.maxsize):
               self.put("stop")

   def custome_pool(task_func, max_workers):
       queue = MyQueue(max_workers)
       for n in range(max_workers):
           t = threading.Thread(target=task_func, args=(queue,))
           t.daemon = True
           t.start()

       return queue



   pool = custome_pool(task_func=target, max_workers=5)

   for i in range(10):
       pool.put(do_task)

   pool.close()
   pool.join()

输出是和上面是完全一样的效果

.. code:: python

   running thread-123145469886464:0
   running thread-123145475141632:0
   running thread-123145485651968:0
   running thread-123145490907136:0
   running thread-123145480396800:0
   running thread-123145469886464:1
   running thread-123145480396800:1
   running thread-123145475141632:1
   running thread-123145490907136:1
   running thread-123145485651968:1
   ...

构建线程池的方法，是可以很灵活的，大家有空可以自己多研究。但是建议只要掌握一种自己熟悉的，能快速上手的就好了。

2. 进程池的创建
---------------

--------------

.. figure:: http://image.python-online.cn/image-20200320125724880.png
   :alt: 关注公众号，获取最新干货！

   关注公众号，获取最新干货！
