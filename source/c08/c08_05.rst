8.5 OpenStack 源码剖析与改造
============================

8.5.1 虚拟机是如何创建出来的？
------------------------------

生成xml，准备网络（plug_vif）创建domain 是在
``_create_domain_and_network`` 这个函数中

|image0|

这个函数，只有在 ``spawn`` 、\ ``_hard_reboot`` 和 ``finish_migration``
才会执行。

8.5.3 创建快照代码解读？
------------------------

8.5.4 虚拟机状态
----------------

vm_state 描述虚拟机当前的稳定状态，其值可以在
``nova/compute/vm_states.py``\ 看到

::

   ACTIVE
   BUILDING
   PAUSED
   SUSPENDED
   STOPPED
   RESCUED
   RESIZED
   SOFT_DELETED
   DELETED
   ERROR
   SHELVED

power_state
描述的是从hypervisor传过来的状态，其值可在\ ``nova/compute/power_state.py``

::

   NOSTATE
   RUNNING
   PAUSED
   SHUTDOWN
   CRASHED
   SUSPENDED

task_state 描述的是中间任务状态，

::

   spawning
   networking
   scheduling
   block_device_mapping

在创建虚拟机时，会有几次会产生虚拟机状态（vm_state和task_state）的上报（到ceilomet
er）。

nova
提供了一个配置项：notify_on_state_change，本意是想，如果配置\ ``vm_state``\ 就只在vm_state

第一次，在\ ``manager.py:2050``\ 的函数
``_do_build_and_run_instance``\ 里，看instance.save()

8.5.5 快照镜像如何实现？
------------------------

nova-api 的入口如下

|image1|

接着会调用 nova/compute/api.py

|image2|

在nova-compute 层面：nova/compute/manager.py:_snapshot_instance()

|image3|

接下来会调用 ``nova/virt/libvirt/driver.py:snapshot()``

|image4|

先获取imagebackend的类型，然后找到对应的backend

.. code:: python

   disk_path, source_format = libvirt_utils.find_disk(virt_dom)
   source_type = libvirt_utils.get_disk_type_from_path(disk_path)
   ...
   snapshot_backend = self.image_backend.snapshot(instance,
                                                  disk_path,
                                                  image_type=source_type)

接下来，会调用对应的imagebackend的\ ``snapshot_extract`` 方法。

|image5|

``snapshot_extract``
方法最终会调用\ ``nova/virt/images.py:_convert_image()``
，可以看出其实底层调用的是 ``qemu-img`` 提供的\ ``convert`` 接口。

|image6|

如果是qcow2的backend，不是调用这边，而是调用
``nova/virt/libvirt/utils.py:extract_snapshot()``

.. figure:: C:\Users\wangbm\AppData\Roaming\Typora\typora-user-images\1551944122412.png
   :alt: 1551944122412

   1551944122412

如果要查询镜像压缩的时间，可以在compute上执行这个命令

::

   grep -E "Start executing commands|End executing commands" /var/log/nova/nova-compute.log

以上，就是整个镜像创建的过程。

独立磁盘模式的暂时不支持，原因分析如下。

在\ ``libvirt_utils.get_disk_type_from_path``
里没有相应的修改，导致返回的是lvm。

|image7|

后面的imagebackend也相应的变成 lvm的

|image8|

然后会进入 lvm这个backend的init函数。由于\ ``path`` 是\ ``/dev/sdb``
并不是一个lv，所以这边会报错。

.. figure:: C:\Users\wangbm\AppData\Roaming\Typora\typora-user-images\1551940635806.png
   :alt: 1551940635806

   1551940635806

下次修改方法：一个是最开始获取\ ``source_type``\ 时判断为isolate，一个是后面
``isolate``\ 的\ ``extract_snapshot`` 也要和lvm一样实现一下。

8.5.6 宿主机资源采集上报
------------------------

compute的资源上报，是在
``nova/compute/resource_tracker.py:_init_compute_node`` 里。

从宿主机上获取数据：\ ``update_available_resource`` 函数下的
``resources = self.driver.get_available_resource(self.nodename)``
其调用的函数是\ ``virt/libvirt/driver.py`` 里的
``get_available_resource`` 函数

|image9|

从数据库获取旧数据
``self.compute_node = self._get_compute_node(context)``

8.5.7 资源主机调度实现
----------------------

一般情况下一个 OpenStack
中，会部署有许多个计算节点。当我们创建一个虚拟机时，OpenStack
如何决定要将我们的虚拟机创建在哪里呢？这就是 openstack-nova-scheduler
要做的事，顾名思义，它是对集群内的所有计算节点的资源情况进行比较，从而选出一台最适合我们当前虚拟机创建的节点，再把请求发到
这一台节点上的 openstack-nova-compute 去进行真正的创建过程。

从源代码中看，最开始是 nova-conductor （nova/conductor/manager.py）在给
nova-compute 发创建请求前，会先让 nova-scheduler
选出一台资源充足的计算节点。

|image10|

nova-scheduler 的调度主要由两部分组成

|image11|

-  过滤器：filter，将不满足条件（硬性条件，比如内存，cpu，磁盘，pci设备等）的计算节点，直接过滤掉。意义：从过滤器出来的那些计算节点，理论上都可以创建虚拟机。
-  称重器：weigher，对满足硬性条件的众多主机按照一定的规则进行权重配比。意义：经过称重器计算，选出你更希望在哪台节点上创建虚拟机。

不管是过滤器，还是称重器，它们都需要两个参数

-  hosts：多个 host_state
   的集合，包含有当前可用的计算节点信息（资源，ip等）。其中单个元素是
   HostState
   （nova/scheduler/host_manager.py）类的实例。如果你想添加其他原来没有的信息，比如
   compute 的 id，可以在 ``_update_from_compute_node``
   函数中添加。它会从compute_nodes 表中取得你想要的信息。

   |image12|

-  spec_obj：你所要请求创建的虚拟机信息（模板，镜像等）。它是从
   objects.RequestSpec.from_primitives 中取得的

   |image13|

过滤器，它的代码如下：

|image14|

称重器，它的规则主要看这段代码。

|image15|

我在代码中，加了几段日志。从左到右，三个不同颜色的内容分别为，原始权值，配重系数（越高说明越占比越大，越影响最终结果），经过
nomalize 后的权值（只有 0 和 1，我觉得原代码这块应该要有浮点数）。

|image16|

那最终的权值如何计算呢？

1. 先计算每一个称重器后的权重： weights \* multipier
2. 最后按不同的compute 将权重相加起来。

8.5.8 手动引入上下文环境
------------------------

有两种方式可以生成context

1. 如果有请求req（在nova-api里），可以使用这种

|image17|

2. 其他地方可以使用这种

|image18|

8.5.9 指定ip时检查allocation_pools
----------------------------------

在原生的 neutron 中，当你指定 ip（172.20.22.64）
来创建虚拟机时，假如子网的 allocation_pools 是 172.20.20.100 -
172.20.20.200 ，那 neutron 是不会去检查你指定的ip是否在 allocation_pools
中的。

先来看看，port 是如何创建的

|image19|

若要解决这个问题，可以参考原生代码中，在为子网添加allocation_pool时，验证是否合法的的逻辑，代码如下

|image20|

然后在 ``neutron\neutron\db\ipam_pluggable_backend.py``
文件中添加我们检查 ip是否在 allocation_pools 中的逻辑代码。

|image21|

.. code:: python

       # 代码如下：方便复制
       @staticmethod
       def _is_ip_in_allocation_pools(ip_address, allocation_pools):
           from neutron.ipam.exceptions import InvalidIpForAllocationPools

           for ap in allocation_pools:
               ap_start_ip = netaddr.IPAddress(ap['start'])
               ap_end_ip = netaddr.IPAddress(ap['end'])
               if ap_start_ip <= ip_address <= ap_end_ip:
                   return True
           raise InvalidIpForAllocationPools(ip_address='ip_address')

       def _validate_allocation_pool_for_fixed_ip(self, subnet, fixed):
           ip_address = netaddr.IPAddress(fixed["ip_address"])
           allocation_pools = subnet["allocation_pools"]
           return self._is_ip_in_allocation_pools(ip_address, allocation_pools)

然后还要定义一个异常类型

|image22|

若指定的ip在allocation pool 里，则正常创建，若不在allocation 里，就会在
nova-compute 日志中报错。

|image23|

可以发现我们的ip 172.20.22.64 并不在子网的allocation
pool，理所当然在nova的日志中可以看到相应的报错。

|image24|

8.5.10 attach port时ip占用提示
------------------------------

当你调用 ``os-interface``
（指定了ip）接口给一台虚拟机添加一张网卡时，若这个ip已经被使用。

nova-api 返回的结果令人无法理解：

::

    [{"computeFault": {"message": "Unexpected API Error. Please report this at http://bugs.launchpad.net/nova/ and attach the Nova API log if possible.\n<class 'oslo_messaging.rpc.client.RemoteError'>", "code": 500}}]. 

究其原因，是 nova 在调用neutron的api
创建port时，如果ip已被占用，必须neutron会抛出
IpAddressAlreadyAllocated，而在 neutronclient 只有 IpAddressInUseClient
的异常，并不匹配，在neutronclient 端与neutron 对应的异常应该为
IpAddressAlreadyAllocatedClient 。

|image25|

如何让nova-api能够返回具体的错误信息呢？

解决方法有两种，

一种是，在 neutronclient/common/exceptions.py 里添加
IpAddressAlreadyAllocatedClient 异常。

并且在nova 创建port的代码处，捕获这个异常

|image26|

这种要改两个组件，而且要将neutronclient 的代码也管理起来，较为麻烦

一种是，只改neutron，在neutron/ipam/exceptions.py 添加一个与
neutronclient 相对应的异常。

|image27|

然后修改 neutron/ipam/drivers/neutrondb_ipam/drivers.py 修改异常类型

|image28|

通过 postman 进行模拟，已经可以返回具体的信息

|image29|

另附：neutron 是如何判断ip是否已经占用？代码如下

|image30|

8.5.11 nova的各项服务服务是如何启动的？
---------------------------------------

nova 里有不少服务，比如
nova-compute，nova-api，nova-conductor，nova-scheduler 等。

这些服务如何都是如何启动的呢？他们其实都是用同一套代码，所以只要分析一个就行，这里以nova-compute为例来了解一下。

从 /usr/bin/nova-compute 这个文件可以了解到nova-compute的入口是
``nova.cmd.compute:main()``

|image31|

从这个入口进去，会开启一个 ``nova-compute`` 的服务。

|image32|

当调用 service.Service.create 时，实际是返回实际化 service.Service
对象。当没有传入 manager 时，就以binary 里的为准。比如binary
是\ ``nova-compute``\ ，那manager_cls 就是
``compute_manager``\ ，对应的manager 导入路径，就会从配置里读取。

|image33|

--------------

.. figure:: http://image.python-online.cn/20190511161447.png
   :alt: 关注公众号，获取最新干货！


.. |image0| image:: http://image.python-online.cn/20190526144846.png
.. |image1| image:: http://image.python-online.cn/20190508110723.png
.. |image2| image:: http://image.python-online.cn/20190508111109.png
.. |image3| image:: http://image.python-online.cn/20190508095028.png
.. |image4| image:: http://image.python-online.cn/20190508111527.png
.. |image5| image:: http://image.python-online.cn/FhRPy4B1xEI9SfoD2RcunJl15ZE3
.. |image6| image:: http://image.python-online.cn/FuyMWZS6HF4g3rPwTlLcereZxg4L
.. |image7| image:: http://image.python-online.cn/FnJA8RNIvJN2lAEXbKtJDpOLg1vg
.. |image8| image:: http://image.python-online.cn/FnGyI8jCQFLCGi0pGVmI3SV6pDrv
.. |image9| image:: http://image.python-online.cn/FrbE6oEZ3vtTWwDfMNQ16MGi6SWr
.. |image10| image:: http://image.python-online.cn/20190424212211.png
.. |image11| image:: http://image.python-online.cn/20190424213430.png
.. |image12| image:: http://image.python-online.cn/20190424214653.png
.. |image13| image:: http://image.python-online.cn/20190424214540.png
.. |image14| image:: http://image.python-online.cn/20190424221602.png
.. |image15| image:: http://image.python-online.cn/20190424215735.png
.. |image16| image:: http://image.python-online.cn/20190424220008.png
.. |image17| image:: http://image.python-online.cn/20190426153322.png
.. |image18| image:: http://image.python-online.cn/20190426152148.png
.. |image19| image:: http://image.python-online.cn/20190526141815.png
.. |image20| image:: http://image.python-online.cn/20190526142453.png
.. |image21| image:: http://image.python-online.cn/20190526134519.png
.. |image22| image:: http://image.python-online.cn/20190526141226.png
.. |image23| image:: http://image.python-online.cn/20190526134543.png
.. |image24| image:: http://image.python-online.cn/20190526134618.png
.. |image25| image:: http://image.python-online.cn/20190526140213.png
.. |image26| image:: http://image.python-online.cn/20190526140301.png
.. |image27| image:: http://image.python-online.cn/20190526140315.png
.. |image28| image:: http://image.python-online.cn/20190526140336.png
.. |image29| image:: http://image.python-online.cn/20190526140410.png
.. |image30| image:: http://image.python-online.cn/20190526143235.png
.. |image31| image:: http://image.python-online.cn/20190526205152.png
.. |image32| image:: http://image.python-online.cn/20190526165007.png
.. |image33| image:: http://image.python-online.cn/20190526204328.png

