# 8.5 OpenStack 源码剖析与改造

## 8.5.1 虚拟机是如何创建出来的？



生成xml，准备网络（plug_vif）创建domain 是在 `_create_domain_and_network` 这个函数中

![](http://image.python-online.cn/20190526144846.png)

这个函数，只有在 `spawn` 、`_hard_reboot` 和 `finish_migration` 才会执行。

通过libvirt的接口创建虚拟机

![](http://image.python-online.cn/20190529135942.png)

## 8.5.2 同步虚机电源状态

虚拟机在 hypervisor 的真实状态和 OpenStack 数据库管理的状态可能有出入。

比如客户可能在虚拟机内部自己执行 `shutdown -h now` ，那么虚机就进入合理正常的关机状态了，可这个状态并不是由 OpenStack 触发的，所以OpenStack 需要定时任务去检查真实的电源状态，并实时更新。

这个定时任务是利用 `eventlet` 这个库去做的

```python
class ComputeManager(manager.Manager):
    def __init__(self, compute_driver=None, *args, **kwargs):
        # CONF.sync_power_state_pool_size 默认是 1000
    	self._sync_power_pool = eventlet.GreenPool(
            size=CONF.sync_power_state_pool_size)
        self._syncs_in_progress = {}
```

默认是 600s，就是10分钟同步一次数据库的状态。

![](http://image.python-online.cn/20190530204839.png)

具体的函数是在这个 `_sync_instance_power_state`

![](http://image.python-online.cn/20190530204505.png)

注意这个函数只有两个地方会调用

一个是上面 时间间隔 10分钟 的定时任务，时间明显有点长。

还有一个是由 libvirt 触发的`lifecycle event` 事件，这个只要在虚拟机在hypervisor层发生状态变动时，就会调用。

![](http://image.python-online.cn/20190530210912.png)

## 8.5.3 创建快照代码解读？



## 8.5.4 虚拟机状态

vm_state 描述虚拟机当前的稳定状态，其值可以在 `nova/compute/vm_states.py`看到

```
ACTIVE
BUILDING
PAUSED
SUSPENDED
STOPPED
RESCUED
RESIZED
SOFT_DELETED
DELETED
ERROR
SHELVED
```

power_state 描述的是从hypervisor传过来的状态，其值可在`nova/compute/power_state.py`

```
NOSTATE
RUNNING
PAUSED
SHUTDOWN
CRASHED
SUSPENDED
```

task_state 描述的是中间任务状态，

```
spawning
networking
scheduling
block_device_mapping
```

在创建虚拟机时，会有几次会产生虚拟机状态（vm_state和task_state）的上报（到ceilomet er）。

nova 提供了一个配置项：notify_on_state_change，本意是想，如果配置`vm_state`就只在vm_state

第一次，在`manager.py:2050`的函数 `_do_build_and_run_instance`里，看instance.save()



## 8.5.5 快照镜像如何实现？

nova-api 的入口如下

![](http://image.python-online.cn/20190508110723.png)

接着会调用 nova/compute/api.py

![](http://image.python-online.cn/20190508111109.png)

在nova-compute 层面：nova/compute/manager.py:_snapshot_instance()

![](http://image.python-online.cn/20190508095028.png)

接下来会调用 `nova/virt/libvirt/driver.py:snapshot()`

![](http://image.python-online.cn/20190508111527.png)

先获取imagebackend的类型，然后找到对应的backend

```python
disk_path, source_format = libvirt_utils.find_disk(virt_dom)
source_type = libvirt_utils.get_disk_type_from_path(disk_path)
...
snapshot_backend = self.image_backend.snapshot(instance,
                                               disk_path,
                                               image_type=source_type)
```

接下来，会调用对应的imagebackend的`snapshot_extract` 方法。

![](http://image.python-online.cn/FhRPy4B1xEI9SfoD2RcunJl15ZE3)

`snapshot_extract` 方法最终会调用`nova/virt/images.py:_convert_image()` ，可以看出其实底层调用的是 `qemu-img` 提供的`convert` 接口。

![](http://image.python-online.cn/FuyMWZS6HF4g3rPwTlLcereZxg4L)

如果是qcow2的backend，不是调用这边，而是调用 `nova/virt/libvirt/utils.py:extract_snapshot()`

![1551944122412](C:\Users\wangbm\AppData\Roaming\Typora\typora-user-images\1551944122412.png)

如果要查询镜像压缩的时间，可以在compute上执行这个命令

```
grep -E "Start executing commands|End executing commands" /var/log/nova/nova-compute.log
```

以上，就是整个镜像创建的过程。

独立磁盘模式的暂时不支持，原因分析如下。

在`libvirt_utils.get_disk_type_from_path` 里没有相应的修改，导致返回的是lvm。

![](http://image.python-online.cn/FnJA8RNIvJN2lAEXbKtJDpOLg1vg)

后面的imagebackend也相应的变成 lvm的

![](http://image.python-online.cn/FnGyI8jCQFLCGi0pGVmI3SV6pDrv)

然后会进入 lvm这个backend的init函数。由于`path` 是`/dev/sdb` 并不是一个lv，所以这边会报错。

![1551940635806](C:\Users\wangbm\AppData\Roaming\Typora\typora-user-images\1551940635806.png)

下次修改方法：一个是最开始获取`source_type`时判断为isolate，一个是后面 `isolate`的`extract_snapshot` 也要和lvm一样实现一下。



## 8.5.6 宿主机资源采集上报

compute的资源上报，是在 `nova/compute/resource_tracker.py:_init_compute_node` 里。

从宿主机上获取数据：`update_available_resource` 函数下的 `resources = self.driver.get_available_resource(self.nodename)` 其调用的函数是`virt/libvirt/driver.py` 里的 `get_available_resource` 函数

![](http://image.python-online.cn/FrbE6oEZ3vtTWwDfMNQ16MGi6SWr)


从数据库获取旧数据 `self.compute_node = self._get_compute_node(context)` 

## 8.5.7 资源主机调度实现

一般情况下一个 OpenStack 中，会部署有许多个计算节点。当我们创建一个虚拟机时，OpenStack 如何决定要将我们的虚拟机创建在哪里呢？这就是 openstack-nova-scheduler 要做的事，顾名思义，它是对集群内的所有计算节点的资源情况进行比较，从而选出一台最适合我们当前虚拟机创建的节点，再把请求发到 这一台节点上的 openstack-nova-compute 去进行真正的创建过程。

从源代码中看，最开始是 nova-conductor （nova/conductor/manager.py）在给 nova-compute 发创建请求前，会先让 nova-scheduler 选出一台资源充足的计算节点。

![](http://image.python-online.cn/20190424212211.png)

nova-scheduler 的调度主要由两部分组成

![](http://image.python-online.cn/20190424213430.png)

- 过滤器：filter，将不满足条件（硬性条件，比如内存，cpu，磁盘，pci设备等）的计算节点，直接过滤掉。意义：从过滤器出来的那些计算节点，理论上都可以创建虚拟机。
- 称重器：weigher，对满足硬性条件的众多主机按照一定的规则进行权重配比。意义：经过称重器计算，选出你更希望在哪台节点上创建虚拟机。

不管是过滤器，还是称重器，它们都需要两个参数

- hosts：多个 host_state 的集合，包含有当前可用的计算节点信息（资源，ip等）。其中单个元素是 HostState （nova/scheduler/host_manager.py）类的实例。如果你想添加其他原来没有的信息，比如 compute 的 id，可以在 `_update_from_compute_node`  函数中添加。它会从compute_nodes 表中取得你想要的信息。

  ![](http://image.python-online.cn/20190424214653.png)

- spec_obj：你所要请求创建的虚拟机信息（模板，镜像等）。它是从 objects.RequestSpec.from_primitives 中取得的

  ![](http://image.python-online.cn/20190424214540.png)


过滤器，它的代码如下：

![](http://image.python-online.cn/20190424221602.png)

称重器，它的规则主要看这段代码。

![](http://image.python-online.cn/20190424215735.png)

我在代码中，加了几段日志。从左到右，三个不同颜色的内容分别为，原始权值，配重系数（越高说明越占比越大，越影响最终结果），经过 nomalize 后的权值（只有 0 和 1，我觉得原代码这块应该要有浮点数）。

![](http://image.python-online.cn/20190424220008.png)

那最终的权值如何计算呢？

1. 先计算每一个称重器后的权重： weights * multipier
2. 最后按不同的compute 将权重相加起来。



## 8.5.8 手动引入上下文环境

有两种方式可以生成context

1. 如果有请求req（在nova-api里），可以使用这种

![](http://image.python-online.cn/20190426153322.png)

2. 其他地方可以使用这种

![](http://image.python-online.cn/20190426152148.png)

## 8.5.9 指定ip时检查allocation_pools

在原生的 neutron 中，当你指定 ip（172.20.22.64） 来创建虚拟机时，假如子网的 allocation_pools 是 172.20.20.100 - 172.20.20.200 ，那 neutron 是不会去检查你指定的ip是否在 allocation_pools 中的。

先来看看，port 是如何创建的

![](http://image.python-online.cn/20190526141815.png)



若要解决这个问题，可以参考原生代码中，在为子网添加allocation_pool时，验证是否合法的的逻辑，代码如下

![](http://image.python-online.cn/20190526142453.png)

然后在 `neutron\neutron\db\ipam_pluggable_backend.py` 文件中添加我们检查 ip是否在 allocation_pools 中的逻辑代码。

![](http://image.python-online.cn/20190526134519.png)

```python
    # 代码如下：方便复制
    @staticmethod
    def _is_ip_in_allocation_pools(ip_address, allocation_pools):
        from neutron.ipam.exceptions import InvalidIpForAllocationPools

        for ap in allocation_pools:
            ap_start_ip = netaddr.IPAddress(ap['start'])
            ap_end_ip = netaddr.IPAddress(ap['end'])
            if ap_start_ip <= ip_address <= ap_end_ip:
                return True
        raise InvalidIpForAllocationPools(ip_address='ip_address')

    def _validate_allocation_pool_for_fixed_ip(self, subnet, fixed):
        ip_address = netaddr.IPAddress(fixed["ip_address"])
        allocation_pools = subnet["allocation_pools"]
        return self._is_ip_in_allocation_pools(ip_address, allocation_pools)
```

然后还要定义一个异常类型

![](http://image.python-online.cn/20190526141226.png)

若指定的ip在allocation pool 里，则正常创建，若不在allocation 里，就会在 nova-compute 日志中报错。

![](http://image.python-online.cn/20190526134543.png)

可以发现我们的ip 172.20.22.64 并不在子网的allocation pool，理所当然在nova的日志中可以看到相应的报错。

![](http://image.python-online.cn/20190526134618.png)

## 8.5.10 attach port时ip占用提示

当你调用 `os-interface` （指定了ip）接口给一台虚拟机添加一张网卡时，若这个ip已经被使用。

nova-api 返回的结果令人无法理解：

```
 [{"computeFault": {"message": "Unexpected API Error. Please report this at http://bugs.launchpad.net/nova/ and attach the Nova API log if possible.\n<class 'oslo_messaging.rpc.client.RemoteError'>", "code": 500}}]. 
```

究其原因，是 nova 在调用neutron的api 创建port时，如果ip已被占用，必须neutron会抛出 IpAddressAlreadyAllocated，而在 neutronclient 只有 IpAddressInUseClient 的异常，并不匹配，在neutronclient 端与neutron 对应的异常应该为 IpAddressAlreadyAllocatedClient 。

![](http://image.python-online.cn/20190526140213.png)

如何让nova-api能够返回具体的错误信息呢？

解决方法有两种，

一种是，在 neutronclient/common/exceptions.py 里添加 IpAddressAlreadyAllocatedClient 异常。

并且在nova 创建port的代码处，捕获这个异常

![](http://image.python-online.cn/20190526140301.png)

这种要改两个组件，而且要将neutronclient 的代码也管理起来，较为麻烦

一种是，只改neutron，在neutron/ipam/exceptions.py 添加一个与 neutronclient 相对应的异常。

![](http://image.python-online.cn/20190526140315.png)

然后修改 neutron/ipam/drivers/neutrondb_ipam/drivers.py 修改异常类型

![](http://image.python-online.cn/20190526140336.png)

通过 postman 进行模拟，已经可以返回具体的信息

![](http://image.python-online.cn/20190526140410.png)

另附：neutron 是如何判断ip是否已经占用？代码如下

![](http://image.python-online.cn/20190526143235.png)

## 8.5.11 nova-compute 如何启动的？

从 /usr/bin/nova-compute 这个文件可以了解到nova-compute的入口是 `nova.cmd.compute:main()`

![](http://image.python-online.cn/20190526205152.png)

从这个入口进去，会开启一个 `nova-compute` 的服务。

![](http://image.python-online.cn/20190526165007.png)

当调用 service.Service.create 时（create 是一个工厂函数），实际是返回实例化的 service.Service 对象。当没有传入 manager 时，就会以binary 里的为准。比如binary 是` nova-compute`，那manager_cls 就是 `compute_manager`，对应的manager 导入路径，会从配置里读取。

![](http://image.python-online.cn/20190526204328.png)

## 8.5.13 支持指定子网和指定ip

在 nova-api 接收请求处。

![](http://image.python-online.cn/20190529203441.png)

![](http://image.python-online.cn/20190529215953.png)

对 network_info 进行解析，然后塞给 request 对象返回。

![](http://image.python-online.cn/20190529215825.png)

---

![关注公众号，获取最新干货！](http://image.python-online.cn/20190511161447.png)