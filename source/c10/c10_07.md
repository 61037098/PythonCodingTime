# 10.7 网络知识扫盲：CSRF 跨域认证与JWT

![](http://image.iswbm.com/20200602135014.png)



## 1. 什么是跨域请求

要明白什么叫跨域请求，首先得知道什么叫域。

域，是指由 `协议` + `域名` + `端口号` 组成的一个虚拟概念。

![](http://image.iswbm.com/20200705171112.png)

如果两个域的协议、域名、端口号都一样，就称他们为同域，但是只要有其中一个不一样，就不是同域。

那么 `跨域请求` 又是什么意思呢？

简单来说，就是在一个域内请求了另一个域的资源，由于域不一致，会有安全隐患。



## 2. 跨域请求的安全隐患

有一个词，叫 CSRF （Cross-site request forgery）攻击，中文名是 `跨站请求伪造`。

简单来说呢，就是攻击者盗用了你的身份，以你的名义发送恶意请求，它能做的坏事有很多，比如以你的名义发邮件，发消息，购物，盗取帐号等。

CSRF 的实际工作原理是怎样的？

比如现在有两个网站，A 网站是真实受信息的网站，而 B网站是危险网站。

当你登陆 A 网站后，浏览器会存储 A 网站服务器给你生成的 sessionid 存入 cookie，有了这个 cookie ，就拥有了你的帐号权限，以后请求资料，就不用再次登陆啦。

对于真实用户来说，是便利，可对于攻击者来说，却是可乘之机。

![](http://image.iswbm.com/20200705172457.png)

他们可以使用各种社工学引导你点击他们的链接/网站，然后利用你的浏览器上存储的 cookie ，然后在自己的 网站B 发起对 网站A 的请求，获取一些隐私信息，做一些侵害用户权益的事情。这便是一个完整的 CSRF 攻击。



## 3. 跨域请求的安全防御

完成一次完整的 CSRF 攻击，只有两个步骤：

1. 登录受信任网站A，并在本地生成Cookie
2. 在不登出A的情况下，访问危险网站B

只要其中一个条件不满足，CSRF 攻击就不会发生。

由于 cookie 机制出现得比较早，且应用比较广泛，所以早期要防御 CSRF 攻击，通常都是从 第二个步骤入手。

很多浏览器用户对于网络安全是无意识的，因此我们不能指望通过规范用户行为来避免CSRF攻击。

那如何从技术手段规避一定的 CSRF 攻击的风险呢？

1. 利用浏览器的同源策略：最基础的安全策略
2. 对请求的来源进行验证：Referer Check
3. 使用验证码强制使用户进行交互确认，保证请求是用户发起
4. CSRF Token
5. JSON Web Token

以上是我知道的历史上用来抵御 CSRF 攻击的方法

- 有的虽然实现简单，但是不够安全

- 有的虽然安全，但是用户体验不好

- 有的虽然安全，用户体验好，但是有缺点


只有一种是最优解，具体是哪一种，请继续往下看

### 3.1 同源策略

浏览器上有一个同源策略（SOP，全称 Same origin policy），它会在一定程度上禁止这种跨域请求的发生。

但同源策略是最基本的安全策略，对于低级的 CSRF 攻击 ，它是很有效果的。

可以说 Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。

同源策略在提升了 Web前端的安全性的同时，也牺牲了Web拓展上的灵活性。

设想若把html、js、css、flash，image等文件全部布置在一台服务器上，小网站这样凑活还行，大中网站如果这样做服务器根本受不了的，因此同源策略，就像是双刃剑。不过这些都是有解的。

### 3.2 Referer Check

在 HTTP 协议中，有一个字段叫做 Referer，它记录了HTTP 请求的来源地址。

当发生 CSRF 攻击时，这个来源地址，会变成危险网站 B，因此只要在服务端校验这个 Referer 是不是和自己同一个域就可以判断这个请求是跨站请求。

但这种方法，也是有局限性的，在一些非主流的浏览器，或者使用了那些非常古老的浏览器版本，这个  Referer 字段，是有可能会被篡改的。

退一步讲，假设你使用了最安全的最新版本的浏览器，这个值无法被篡改，依旧还是有安全隐患。

因为有些用户出于某些隐私考虑，会在浏览器设置关闭这个 Referer 字段，也有的网站会使用一些技术手段使用请求不携带 Referer 字段。

因此我们发现了只要需要客户端配合的解决方案，就有无穷无尽的场景，场景越多，可能性越多，可以被突破的漏洞就越多。

到头后，我还是只能将希望寄托于服务端。

### 3.3 加验证码

验证码，强制用户必须与应用进行交互，才能完成最终请求。

在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。

### 3.4 CSRF Token

 CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下，直接利用用户自己的 cookie 来通过安全验证。

所以要抵御 CSRF，关键在于要在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中（不然黑客又能拿到了）。

业界普遍的防御方案是使用 CSRF Token，具体流程如下：

1. 当用户请求一个页面时，服务端会生成一个随机的 Token，并把这个 Token 存放在 Session 里（也就是内存中），然后放入HTML表单中传给浏览器；

2. 当用户提交表单请求时，会带上这个 Token 发送给服务端 ；
3. 服务端收到表单请求后，会从表单数据里取出 Token，然后和 session 里的 token 进行对比，如果是一样的，就是合法的用户请求，如果不一样，那就是非法的请求，应当拒绝。

在这里面有几点值得注意：

1. 由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。
2. 虽然也可以通过cookie 的方式将 Token 传给浏览器，但是有了以前的经验，你会发现这种方法 Token 还是会被危险网站给【利用】（注意这里是利用，而不是获取），然后发送非法的跨域请求。

### 3.5 新增 Header

CSRF 跨域攻击能够成功的最根本原因，是我们使用了 cookie，因此如果要杜绝 CSRF 的产生，就要一定要抛弃 cookie。

上面的 CSRF Token 就是没有使用 cookie ，才得以避免了 CSRF 的攻击问题。

 CSRF Token 虽然能解决问题，但是解决得并不完美。

CSRF Token 如果不想使用 cookie，就必须要将 Token 存储在服务端的内存中，这样就会面临几个问题

1. 服务端每生成一个 Token，都会将以 session 形式都是保存在内存中，而随着用户请求的增多，服务端的开销会明显增大。
2. 如果网站有多个子域，分别对应不同的服务器，比如 taobao.com 后台是服务器 a，zhibo.baotao.com 后台是 服务器b， 不同子域要想使用同一个 Token，就要求所有的服务器要能共享这个 Token。一般要有一个中心节点（且应是一个集群）来存储这个Token，这样看下来，架构就变得更加复杂了。

想要解决这些问题，也不困难，现如今已经有很好的方案了，那就是 JWT（全称：JSON Web Token）

使用了 JWT 后，有了哪些变化呢

1. 服务器只负责生成Token和校验Token，而不再存储Token
2. 将服务器的压力分摊给了所有的客户端。

JWT 和 CSRF Token 一样，没有使用 Cookie，那么 Token 是如何发送给服务端 的呢，是通过新增的 Header 字段：Authorization

JWT 是本篇文章最重要的知识点，内容也不少，下面我会详细说说关于 JWT 的内容。

## 4. JWT 的工作原理

为了让你直观感受 JWT 的工作原理，我画了下面这张图

1. 用户以 Web表单 的形式，将自己的用户名和密码发送到后端的接口。（HTTPS + POST)；
2. 后端核对用户名和密码成功后，会计算生成JWT Payload 字符串（具体计算方法，后续会讲）返回给前端；
3. 前端收到 JWT 后，会将其保存在 localStorage 或 sessionStorage 上。
4. 后续在该域上发出的请求，都会将 JWT放入HTTP Header 中的 Authorization 字段。(解决XSS和XSRF问题)
5. 后端收到新请求后，如存在验证JWT的有效性（具体如何较验，后面会讲）。
6. 验证通过后后端使用 JWT 中包含的用户信息进行其他逻辑操作，返回相应结果。



## 5. JWT 如何生成？

JWT 其实就是一个字符串，比如下面这样

```shell
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

仔细观察，会发现它里面有三个 `.` ，以 `.` 为分界，可以将 JWT 分为三部分。

1. **第一部分**：头部（Header）
2. **第二部分**：载荷（Payload）
3. **第三部分**：签名（Signature）

### 5.1 头部（Header）

JWT 的头部承载两部分信息：

- 声明类型：这里是 JWT
- 声明加密的算法：通常直接使用 HMAC SHA256

完整的头部就像下面这样的JSON：

```bash
{
  'typ': 'JWT',
  'alg': 'HS256'
}
```

然后将头部进行 Base64URL 算法加密（该加密是可以对称解密的)，构成了第一部分

```undefined
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
```

### 5.2 载荷（Payload）

载荷，同样也是个 JSON 对象，它是存放有效信息的地方，但不建议存放密码等敏感信息。

JWT 规定了7个官方字段，供选用：

- iss (issuer)：签发人 
- exp (expiration time)：过期时间 
- sub (subject)：主题 
- aud (audience)：受众 
- nbf (Not Before)：生效时间 
- iat (Issued At)：签发时间 
- jti (JWT ID)：编号

除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。

注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

然后将其进行 Base64URL 算法加密，得到 JWT 的第二部分。

```undefined
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9
```

### 5.3 签名（Signature）

Signature 部分是对前两部分的签名，防止数据篡改。

首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。

```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（.）分隔，就可以返回给用户。

## 6. Base64URL 算法

前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。

JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。

## 7. JWT 如何发送？

只要客户端收到了 JWT ，后续在这个域里的请求就会自动在 请求头里加入`Authorization`，并加上`Bearer`标注：

```shell
'Authorization': 'Bearer ' + ${token}
```



## 8. JWT 如何校验？

后端收到请求后，从 Header 中取出 `Authorization` 里的 JWT ，使用之前的签名算法对 header 和 payload 再次计算生成新的签名，并与 JWT 里的签名进行对比，如果一样，说明校验通过，是个合法的 Token。

```shell
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

## 9. 总结写在最后

本文先从跨域请求概念的提出，并分析了历史发展中都有哪些防御CSRF的策略，它们是如何有效的杜绝 CSRF 的产生的，最后引出解决 CSRF 的完美方案 ：JWT ，并详细介绍了 JWT 是如何工作的，工作原理是什么？

学完了本文，你应该知道：**cookie 是CSRF 攻击的帮凶，要防御 CSRF ，最好的办法是不使用 cookie，方案有两种：CSRF Token 和 JWT**

而对于 JWT 的知识 ，你应该要知道：

1. JWT 就是一个由服务端按照一定的规则生成的字符串
2. JWT 是基于 JSON的，因此其可以进行跨语言支持的
3. JWT 若没有经过 TLS/SSL 加密， payload 里不要放任何敏感信息
4. JWT 的使用不需要在服务端保存会话信息, 减少了服务器的压力，有利于简化服务端的架构。
5. JWT 若想不被伪造，只要保护好 secret 私钥就行了。
6. JWT 与 HTTPS 协议搭配使用会更安全可靠。 



## 10. 参考文章

- [咱妈说别乱点链接之浅谈CSRF攻击](https://cloud.tencent.com/developer/article/1004943)
- [JSON Web Token 入门教程](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)



![](http://image.iswbm.com/20200607174235.png)
