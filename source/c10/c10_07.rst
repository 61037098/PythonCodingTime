10.7 网络知识扫盲：CSRF 跨域认证与JWT
=====================================

|image0|

|image1|

1. 什么是跨域请求
-----------------

要明白什么叫跨域请求，首先得知道什么叫域。

域，是指由 ``协议`` + ``域名`` + ``端口号`` 组成的一个虚拟概念。

|image2|

如果两个域的协议、域名、端口号都一样，就称他们为同域，但是只要有其中一个不一样，就不是同域。

那么 ``跨域请求`` 又是什么意思呢？

简单来说，就是在一个域内请求了另一个域的资源，由于域不一致，会有安全隐患。

2. 跨域请求的安全隐患
---------------------

有一个词，叫 CSRF （Cross-site request forgery）攻击，中文名是
``跨站请求伪造``\ 。

简单来说呢，就是攻击者盗用了你的身份，以你的名义发送恶意请求，它能做的坏事有很多，比如以你的名义发邮件，发消息，购物，盗取帐号等。

CSRF 的实际工作原理是怎样的？

比如现在有两个网站，A 网站是真实受信息的网站，而 B网站是危险网站。

当你登陆 A 网站后，浏览器会存储 A 网站服务器给你生成的 sessionid 存入
cookie，有了这个 cookie
，就拥有了你的帐号权限，以后请求资料，就不用再次登陆啦。

对于真实用户来说，是便利，可对于攻击者来说，却是可乘之机。

|image3|

他们可以使用各种社工学引导你点击他们的链接/网站，然后利用你的浏览器上存储的
cookie ，然后在自己的 网站B 发起对 网站A
的请求，获取一些隐私信息，做一些侵害用户权益的事情。这便是一个完整的
CSRF 攻击。

3. 跨域请求的安全防御
---------------------

完成一次完整的 CSRF 攻击，只要两个步骤：

1. 登录受信任网站A，并在本地生成Cookie
2. 在不登出A的情况下，访问危险网站B

只要其中一个条件不满足，CSRF 攻击就不会发生。

由于 cookie 机制出现得比较早，且应用比较广泛，所以早期要防御 CSRF
攻击，通常都是从 第二个步骤入手。

很多浏览器用户对于网络安全是无意识的，因此我们不能指望通过规范用户行为来避免CSRF攻击。

那如何从技术手段规避一定的 CSRF 攻击的风险呢？

1. 利用浏览器的同源策略：最基础的安全策略
2. 对请求的来源进行验证：Referer Check
3. 使用验证码强制使用户进行交互确认，保证请求是用户发起
4. CSRF Token，注意不要使用 cookie 来存储token
5. JSON Web Token

以上是我知道的历史上用来抵御 CSRF 攻击的方法

-  有的虽然实现简单，但是不够安全

-  有的虽然安全，但是用户体验不好

-  有的虽然安全，用户体验好，但是有缺点

只有一种是最优解，具体是哪一种？

不防继续往下看

3.1 同源策略
~~~~~~~~~~~~

浏览器上有一个同源策略（SOP，全称 Same origin
policy），它会在一定程度上禁止这种跨域请求的发生。

但同源策略是最基本的安全策略，对于低级的 CSRF 攻击 ，它是很有效果的。

可以说 Web
是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。

同源策略在提升了 Web前端的安全性的同时，也牺牲了Web拓展上的灵活性。

设想若把html、js、css、flash，image等文件全部布置在一台服务器上，小网站这样凑活还行，大中网站如果这样做服务器根本受不了的，因此同源策略，就像是双刃剑。不过这些都是有解的。

3.2 Referer Check
~~~~~~~~~~~~~~~~~

在 HTTP 协议中，有一个字段叫做 Referer，它记录了HTTP 请求的来源地址。

当发生 CSRF 攻击时，这个来源地址，会变成危险网站
B，因此只要在服务端校验这个 Referer
是不是和自己同一个域就可以判断这个请求是跨站请求。

|image4|

但这种方法，也是有局限性的，在一些非主流的浏览器，或者使用了那些非常古老的浏览器版本，这个
Referer 字段，是有可能会被篡改的。

退一步讲，假设你使用了最安全的最新版本的浏览器，这个值无法被篡改，依旧还是有安全隐患。

因为有些用户出于某些隐私考虑，会在浏览器设置关闭这个 Referer
字段，也有的网站会使用一些技术手段使用请求不携带 Referer 字段。

3.3 加验证码
~~~~~~~~~~~~

验证码，强制用户必须与应用进行交互，才能完成最终请求。

其实加验证码，是能很好遏制 CSRF
攻击，但是网站总不能给所有的操作都加上验证码吧，那样的话，用户估计都跑光光了，因此为了保证用户体验，验证码只能作为一种辅助手段，不能作为主要解决方案。

3.4 CSRF Token
~~~~~~~~~~~~~~

CSRF
攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于
cookie 中，因此黑客可以在不知道这些验证信息的情况下，直接利用用户自己的
cookie 来通过安全验证。

所以要抵御
CSRF，关键在于要在请求中放入黑客所不能伪造的信息，并且该信息不存在于
cookie 之中（不然黑客又能拿到了）。

业界普遍的防御方案是使用 CSRF Token，具体流程如下

|image5|

1. 当用户请求一个更新用户名的页面时，服务端会生成一个随机的
   Token，并把这个 Token 存放在 Session
   里（也就是内存中），然后放入HTML表单中传给浏览器；

2. 当用户提交表单请求时，会带上这个 Token 发送给服务端 ；
3. 服务端收到表单请求后，会从表单数据里取出 Token，然后和 session 里的
   token
   进行对比，如果是一样的，就是合法的用户请求，将新的用户名存入数据库，如果不一样，那就是非法的请求，应当拒绝。

在这里面有几点值得注意：

1. 由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。
2. 虽然也可以通过cookie 的方式将 Token
   传给浏览器，但是有了以前的经验，你会发现这种方法 Token
   还是会被危险网站给【利用】（注意这里是利用，而不是获取），然后发送非法的跨域请求。

3.5 新增 Header
~~~~~~~~~~~~~~~

CSRF 跨域攻击能够成功的最根本原因，是我们使用了 cookie，因此如果要杜绝
CSRF 的产生，就要一定要抛弃 cookie。

上面的 CSRF Token 就是没有使用 cookie ，才得以避免了 CSRF 的攻击问题。

CSRF Token 虽然能解决问题，但是解决得并不完美。

CSRF Token 如果不想使用 cookie，就必须要将 Token
存储在服务端的内存中，这样就会面临几个问题

1. 服务端每生成一个 Token，都会将以 session
   形式都是保存在内存中，而随着用户请求的增多，服务端的开销会明显增大。
2. 如果网站有多个子域，分别对应不同的服务器，比如 taobao.com
   后台是服务器 a，zhibo.baotao.com 后台是 服务器b，
   不同子域要想使用同一个 Token，就要求所有的服务器要能共享这个
   Token。一般要有一个中心节点（且应是一个集群）来存储这个Token，这样看下来，架构就变得更加复杂了。

想要解决这些问题，也不困难，现如今已经有很好的方案了，那就是
JWT（全称：JSON Web Token）

使用了 JWT 后，有了哪些变化呢

1. 服务器只负责生成Token和校验Token，而不再存储Token
2. 将服务器的压力分摊给了所有的客户端。

JWT 和 CSRF Token 一样，没有使用 Cookie，那么 Token 是如何发送给服务端
的呢，是通过新增的 Header 字段：Authorization

JWT 是本篇文章最重要的知识点，内容也不少，下面我会详细说说关于 JWT
的内容。

4. JWT 的工作原理
-----------------

为了让你直观感受 JWT 的工作原理，我画了下面这张图

|image6|

1. 用户以 Web表单 的形式，将自己的用户名和密码 POST 到后端的接口。
2. 后端核对用户名和密码成功后，会计算生成JWT Payload
   字符串（具体计算方法，后续会讲），然后返回 response
   给浏览器（包含Set-Cookie: HttpOnly）；
3. 浏览器收到 JWT 后，将其保存在 cookie 里（为什么保存在 cookie
   里，后续会讲）。
4. 后续在该域上发出的请求，都会将 JWT放入HTTP Header 中的 Authorization
   字段。
5. 后端收到新请求后，会使用密钥验证 JWT 签名。
6. 验证通过后后端使用 JWT
   中包含的用户信息进行其他相关操作，返回相应结果。

5. JWT 如何生成？
-----------------

JWT 其实就是一个字符串，比如下面这样

.. code:: shell

   eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ

仔细观察，会发现它里面有三个 ``.`` ，以 ``.`` 为分界，可以将 JWT
分为三部分。

|image7|

1. **第一部分**\ ：头部（Header）
2. **第二部分**\ ：载荷（Payload）
3. **第三部分**\ ：签名（Signature）

|image8|

5.1 头部（Header）
~~~~~~~~~~~~~~~~~~

JWT 的头部承载两部分信息：

-  声明类型：这里是 JWT
-  声明加密的算法：通常直接使用 HMAC SHA256

完整的头部就像下面这样的JSON：

.. code:: bash

   {
     "typ": "JWT",
     "alg": "HS256"
   }

然后将头部进行 Base64URL
算法加密（该加密是可以对称解密的)，构成了第一部分

.. code:: shell

   eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9

5.2 载荷（Payload）
~~~~~~~~~~~~~~~~~~~

载荷，同样也是个 JSON
对象，它是存放有效信息的地方，但不建议存放密码等敏感信息。

JWT 规定了7个官方字段，供选用：

-  iss (issuer)：签发人
-  exp (expiration time)：过期时间
-  sub (subject)：主题
-  aud (audience)：受众
-  nbf (Not Before)：生效时间
-  iat (Issued At)：签发时间
-  jti (JWT ID)：编号

除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。

注意，JWT
默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。

.. code:: json

   {
     "sub": "1234567890",
     "name": "John Doe",
     "admin": true
   }

然后将其进行 Base64URL 算法加密，得到 JWT 的第二部分。

.. code:: shell

   eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9

5.3 签名（Signature）
~~~~~~~~~~~~~~~~~~~~~

Signature 部分是对前两部分的签名，防止数据篡改。

首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用
Header 里面指定的签名算法（默认是 HMAC
SHA256），按照下面的公式产生签名。

::

   HMACSHA256(
     base64UrlEncode(header) + "." +
     base64UrlEncode(payload),
     secret)

算出签名以后，把 Header、Payload、Signature
三个部分拼成一个字符串，每个部分之间用“点”（\ ``.``\ ）分隔，就可以返回给用户。

6. 手动生成 JWT
---------------

如果你想手动生成一个 JWT 用于测试，可以使用
``https://jwt.io/``\ 这个网站 。

我使用前面的 header 和 payload，然后使用 secret 密钥：\ ``Python``

最后生成的 JWT 结果如下

.. code:: shell

   eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.3wGDum3_A8tAt1bdal5CpYbIUlpHfPQxs96Ijx883kI

|image9|

7. Base64URL 算法
-----------------

前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64
算法基本类似，但有一些小的不同。

JWT 作为一个令牌（token），有些场合可能会放到 URL（比如
api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL
里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成\_ 。这就是
Base64URL 算法。

8. JWT 如何保存？
-----------------

关于浏览器应该将 JWT 保存在哪？这个问题，其实也困扰了我很久。

如果使用搜索引擎去查，我相信你也一定会被他们绕晕。

比如在这篇帖子（\ `When and how to use
it <https://blog.logrocket.com/jwt-authentication-best-practices/>`__
）里，作者的观点是，不应该保存在 localstorage 和 session
storage，因为这样，第三方的脚本就能直接获取到。

作者推荐的做法是，将 JWT 保存在 cookie 里，并设置 HttpOnly。

.. figure:: /Users/MING/Library/Application%20Support/typora-user-images/image-20200705233446534.png
   :alt: image-20200705233446534

   image-20200705233446534

再比如这一篇帖子（\ `JWT(JSON Web Token) : Implementation with
Node <https://medium.com/@am_pra_veen/jwt-json-web-token-implementation-with-node-d0661d4c7cbb>`__\ ）提到了要把
JWT 保存到 local-storage。

.. figure:: /Users/MING/Library/Application%20Support/typora-user-images/image-20200705233925900.png
   :alt: image-20200705233925900

   image-20200705233925900

因此，我决定不再看网络上关于 『应将 JWT
保存的哪？』的文章。而是自己思考，以下是我个人观点，不代表一定正确，仅供参考
。

JWT 的保存位置，可以分为如下四种

1. 保存在 localStorage
2. 保存在 sessionStorage
3. 保存在 cookie
4. 保存在 cookie 并设置 HttpOnly

第一种和第二种其实可以归为一类，这一类有个特点，就是该域内的 js
脚本都可以读取，这种情况下 JWT 通过 js 脚本放入 Header 里的
Authorization 字段，会存在 XSS 攻击风险。

第三种，与第四种相比，区别在于 cookie 有没有标记 HttpOnly，没有标记
HttpOnly 的 cookie ，客户端可以将 JWT 通过 js 脚本放入 Header 里的
Authorization 字段。这么看好像同时存在CSRF 攻击风险和 XSS
攻击风险，实则不然，我们虽然将 JWT 存储在 cookie
里，但是我们的服务端并没有利用 cookie 里的 JWT 直接去鉴权，而是通过
header 里的 Authorization 去鉴权，因此这种方法只有 XSS 攻击风险，而没有
CSRF 攻击风险。

而第四种，加了 HttpOnly 标记，意味着这个 cookie
无法通过js脚本进行读取和修改，杜绝了 XSS
攻击的发生。与此同时，网站自身的 js 脚本也无法利用 cookie 设置 header
的Authorization 字段，因此只能通过 cookie 里的 JWT
去鉴权，所以不可避免还是存在 CSRF 攻击风险。

如此看来，好像不管哪一种都有弊端，没有一种完美的解决方案。

.. figure:: /Users/MING/Library/Application%20Support/typora-user-images/image-20200706001903273.png
   :alt: image-20200706001903273

   image-20200706001903273

是的，事实也确实如此。

所以我的观点是，开发人员应当根据实际情况来选择 JWT 的存储位置。

-  当访问量/业务量不是很大时，可以使用 CSRF Token 来防止 CSRF
   攻击，同时这种情况下也不会有 XSS 攻击的风险
-  而如果访问量/业务量对服务器造成很大压力，或觉得服务器共享 token
   对架构要求太高了，那就抛弃CSRF Token 的方式，而改用 JWT。选择了 JWT
   ，就面临着要将 JWT 存储在哪的问题。下面再继续视情况而定
-  若选择了 JWT ，那么要知道 XSS 攻击风险 和 CSRF
   攻击风险，不可避免要面临其中一个（上面那张图已经得出结论），这时候选择哪个就比较哲学了。按照当前的大环境来看，现代成熟的
   Web框架 已经可以轻松地防止CSRF攻击（比如前面讲过的 Referer Check
   、加验证码），而当下的 HTML5好像是更容易会受到 XSS
   攻击，并且在攻击后会有较大的影响，因此在这样的情况下可以尽量避开 XSS
   攻击，而选择第四种：cookie + HttpOnly。
-  亦或者，做为开发者的你，对自己防护 XSS
   攻击有足够的信心，在客户端和服务端，对提交的数据都进行了 xss
   攻击的检查以及转义，这时候你就可以选择前面三种的任意一种。

9. JWT 如何发送？
-----------------

通过上面第七节的描述，其实我也讲到了 JWT
根据不同场景可以选择两种发送方式

-  第一种：将 JWT 放在 Header 里的 ``Authorization`` 字段，并使用
   ``Bearer``\ 标注

.. code:: shell

   'Authorization': 'Bearer ' + ${token}

-  第二种：把 JWT 放入 cookie ，发送给服务端

两种的利弊上面都已经剖析过了，这里不再赘述。

10. JWT 如何校验？
------------------

后端收到请求后，从 Header 中取出 ``Authorization`` 里的 JWT
，使用之前的签名算法对 header 和 payload 再次计算生成新的签名，并与 JWT
里的签名进行对比，如果一样，说明校验通过，是个合法的 Token。

.. code:: shell

   HMACSHA256(
     base64UrlEncode(header) + "." +
     base64UrlEncode(payload),
     secret)

在 JWT 里含有用户的相关信息，如果 Token 合法，那么Server
就可以取出里面的 payload 得知这是属于哪个用户的请求。

11. 总结写在最后
----------------

本文先从跨域请求概念的提出，并分析了历史发展中都有哪些防御CSRF的策略，它们是如何有效的杜绝
CSRF 的产生的，最后引出解决 CSRF 的完美方案 ：JWT ，并详细介绍了 JWT
是如何工作的，工作原理是什么？

学完了本文，你应该知道：\ **cookie 是CSRF 攻击的帮凶，要防御 CSRF
，最好的办法是不使用 cookie，方案有两种：CSRF Token 和 JWT**

而对于 JWT 的知识 ，你应该要知道：

1. JWT 就是一个由服务端按照一定的规则生成的字符串
2. JWT 是基于 JSON的，因此其可以进行跨语言支持的
3. JWT 若没有经过 TLS/SSL 加密， payload 里不要放任何敏感信息
4. JWT 的使用不需要在服务端保存会话信息,
   减少了服务器的压力，有利于简化服务端的架构。
5. JWT 若想不被伪造，只要保护好 secret 私钥就行了。
6. JWT 与 HTTPS 协议搭配使用会更安全可靠。

12. 参考文章
------------

-  `咱妈说别乱点链接之浅谈CSRF攻击 <https://cloud.tencent.com/developer/article/1004943>`__
-  `JSON Web Token
   入门教程 <http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html>`__
-  `Where to Store your JWTs – Cookies vs HTML5 Web
   Storage <https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage>`__

-  `JWT 超详细分析 <https://www.cnblogs.com/DeadBoy/p/11481146.html>`__

|image10|
---------

.. |image0| image:: http://image.iswbm.com/20200602135014.png
.. |image1| image:: http://image.iswbm.com/20200705214412.png
.. |image2| image:: http://image.iswbm.com/20200705171112.png
.. |image3| image:: http://image.iswbm.com/20200705172457.png
.. |image4| image:: http://image.iswbm.com/20200705193118.png
.. |image5| image:: http://image.iswbm.com/20200705211401.png
.. |image6| image:: http://image.iswbm.com/20200705220524.png
.. |image7| image:: http://image.iswbm.com/20200705212820.png
.. |image8| image:: http://image.iswbm.com/20200705215033.png
.. |image9| image:: http://image.iswbm.com/20200706005103.png
.. |image10| image:: http://image.iswbm.com/20200607174235.png

