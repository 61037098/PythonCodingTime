# 1.10 看到这 40个知识点，那些说精通 Python 的人脸都黑了

---


## 01. 万象皆对象，包括省略号

`...` 这是省略号，在Python中，一切皆对象。它也不例外。

在 Python 中，它叫做 Ellipsis 。

在 Python 3 中你可以直接写...来得到这玩意。
```python
>>> ...
Ellipsis
>>> type(...)
<class 'ellipsis'>
```

而在 2 中没有...这个语法，只能直接写Ellipsis来获取。
```python
>>> Ellipsis
Ellipsis
>>> type(Ellipsis)
<type 'ellipsis'>
>>>
```

它转为布尔值时为真
```python
>>> bool(...)
True
```
最后，这东西是一个单例。
```python
>>> id(...)
4362672336
>>> id(...)
4362672336
```

这东西有啥用呢？据说它是Numpy的语法糖，不玩 Numpy 的人，可以说是没啥用的。

在网上只看到这个 用 `...` 代替 pass ，稍微有点用，但又不是必须使用的。
```
try:
    1/0
except ZeroDivisionError:
    ...
```

## 02. 使用 end 增强代码逻辑？

有不少编程语言，循环、判断代码块需要用 end 标明结束，这样一定程度上会使代码逻辑更加清晰一点。

但是其实在 Python 这种严格缩进的语言里并没有必要这样做。

如果你真的想用，也不是没有办法，具体你看下面这个例子。

```python
__builtins__.end = None


def my_abs(x):
    if x > 0:
        return x
    else:
        return -x
    end
end

print(my_abs(10))
print(my_abs(-10))
```

执行后，输出如下

```shell
[root@localhost ~]$ python demo.py 
10
10
```



## 03. 逗号也有它独特的用法

逗号，虽然是个很不起眼的符号，但在 Python 中也有他的用武之地。

**第一个用法**

元组的转化

```shell
[root@localhost ~]# cat demo.py 
def func():
    return "ok",

print(func())
[root@localhost ~]# python3 demo.py 
('ok',)
```

**第二个用法**

print 的取消换行

```shell
[root@localhost ~]# cat demo.py 
for i in range(3):
    print i
[root@localhost ~]# 
[root@localhost ~]# python demo.py 
0
1
2
[root@localhost ~]# 
[root@localhost ~]# vim demo.py 
[root@localhost ~]# 
[root@localhost ~]# cat demo.py 
for i in range(3):
    print i,
[root@localhost ~]# 
[root@localhost ~]# python demo.py 
0 1 2
[root@localhost ~]#
```

## 04. 反斜杠的倔强: 不写最后

`\` 在 Python 中的用法主要有两种

**1、在行尾时，用做续行符**

   ```python
[root@localhost ~]$ cat demo.py 
print("hello "\
      "world")
[root@localhost ~]$ 
[root@localhost ~]$ python demo.py
hello world
   ```



**2、在字符串中，用做转义字符，可以将普通字符转化为有特殊含义的字符。**

```python
>>> str1='\nhello'　　＃换行
>>> print(str1)

hello
>>> str2='\thello'　　＃tab
>>> print(str2)
	hello
```

但是如果你用单`\`结尾是会报语法错误的

```python
>>> str3="\"
  File "<stdin>", line 1
    str3="\"
           ^
SyntaxError: EOL while scanning string literal
```

就算你指定它是个 raw 字符串，也不行。

```python
>>> str3=r"\"
  File "<stdin>", line 1
    str3=r"\"
            ^
SyntaxError: EOL while scanning string literal
```

## 05. 单行实现 for 死循环如何写？

如果让你在不借助 while ，只使用 for 来写一个死循环？

**你会写吗？**

**如果你还说简单，你可以自己试一下。**

...



如果你尝试后，仍然写不出来，那我给出自己的做法。

```python
for i in iter(int, 1):pass
```



**是不是傻了？iter 还有这种用法？这为啥是个死循环？**



关于这个问题，你如果看中文网站，可能找不到相关资料。

还好你可以通过 IDE 看py源码里的注释内容，介绍了很详细的使用方法。

原来iter有两种使用方法。

- 通常我们的认知是第一种，将一个列表转化为一个迭代器。

- 而第二种方法，他接收一个 callable对象，和一个sentinel 参数。第一个对象会一直运行，直到它返回 sentinel 值才结束。

那`int` 呢？

这又是一个知识点，int 是一个内建方法。通过看注释，可以看出它是有默认值0的。你可以在console 模式下输入 `int()` 看看是不是返回0。 

由于int() 永远返回0，永远返回不了1，所以这个 for 循环会没有终点。一直运行下去。

## 06. 懒人必备技能：使用 “_”

对于 `_` ，大家对于他的印象都是用于 **占位符**，省得为一个不需要用到的变量，绞尽脑汁的想变量名。

今天要介绍的是他的第二种用法，就是在 console 模式下的应用。

示例如下：

```python
>>> 3 + 4
7
>>> _
7
>>> name='公众号: Python编程时光'
>>> name
'公众号: Python编程时光'
>>> _
'公众号: Python编程时光'
```

它可以返回上一次的运行结果。

但是，如果是print函数打印出来的就不行了。

```python
>>> 3 + 4
7
>>> _
7
>>> print("公众号: Python编程时光")
ming
>>> _
7
```

我自己写了个例子，验证了下，用`__repr__`输出的内容可以被获取到的。
首先，在我们的目录下，写一个文件 demo.py。内容如下

```python
# demo.py
class mytest():
    def __str__(self):
        return "hello"

    def __repr__(self):
        return "world"
```

然后在这个目录下进入交互式环境。

```python
>>> import demo
>>> mt=demo.mytest()
>>> mt
world
>>> print(mt)
hello
>>> _
world
```

知道这两个魔法方法的人，一看就明白了，这里不再解释啦。

## 07. 最快查看包搜索路径的方式

当你使用 import 导入一个包或模块时，Python 会去一些目录下查找，而这些目录是有优先级顺序的，正常人会使用 sys.path 查看。

```python
>>> import sys
>>> from pprint import pprint   
>>> pprint(sys.path)
['',
 '/usr/local/Python3.7/lib/python37.zip',
 '/usr/local/Python3.7/lib/python3.7',
 '/usr/local/Python3.7/lib/python3.7/lib-dynload',
 '/home/wangbm/.local/lib/python3.7/site-packages',
 '/usr/local/Python3.7/lib/python3.7/site-packages']
>>> 
```

那有没有更快的方式呢？

我这有一种连 console 模式都不用进入的方法，一行命令即可解决

```shell
[wangbm@localhost ~]$ python3 -m site
sys.path = [
    '/home/wangbm',
    '/usr/local/Python3.7/lib/python37.zip',
    '/usr/local/Python3.7/lib/python3.7',
    '/usr/local/Python3.7/lib/python3.7/lib-dynload',
    '/home/wangbm/.local/lib/python3.7/site-packages',
    '/usr/local/Python3.7/lib/python3.7/site-packages',
]
USER_BASE: '/home/wangbm/.local' (exists)
USER_SITE: '/home/wangbm/.local/lib/python3.7/site-packages' (exists)
ENABLE_USER_SITE: True
```

从输出你可以发现，这个列的路径会比 sys.path 更全，它包含了用户环境的目录。

如果你不熟悉用户环境，可以参考我写的另一篇文章：[记 Python “用户环境”的一次完美应用](https://mp.weixin.qq.com/s?__biz=MzIzMzMzOTI3Nw==&mid=2247486191&idx=1&sn=e556df305ce1df4c4969d2fdbe884cfa&chksm=e8866a0ddff1e31b2ca8ca8fbbe0355fb8c24376d715224ef2176e613b5601764be0193e3aa4&token=1343865895&lang=zh_CN#rd)

## 08. and 和 or 的取值顺序

and 和 or 是我们再熟悉不过的两个逻辑运算符，在 Python 也有它有妙用。

- 当一个 **or 表达式**中所有值都为真，Python会选择第一个值

- 当一个 **and 表达式** 所有值都为真，Python 会选择第二个值。

示例如下：

```python
>>>(2 or 3) * (5 and 7)
14  # 2*7
```

## 09. 如何修改解释器提示符

这个当做今天的一个小彩蛋吧。应该算是比较冷门的，估计知道的人很少了吧。

正常情况下，我们在 终端下 执行Python 命令是这样的。
```python
>>> for i in range(2):
...     print (i)
...
0
1
```

你是否想过 `>>>` 和 `...` 这两个提示符也是可以修改的呢？
```python
>>> import sys                      
>>> sys.ps1                         
'>>> '                              
>>> sys.ps2                         
'... '                              
>>>                                 
>>> sys.ps2 = '---------------- '                 
>>> sys.ps1 = 'Python编程时光>>>'       
Python编程时光>>>for i in range(2):     
----------------    print (i)                    
----------------                                 
0                                   
1                                   
```

## 10. 可直接运行 zip 包

我们可以经常看到有 Python 包，居然可以以 zip 包进行发布，并且可以不用解压直接使用。

这与大多数人的认识的 Python 包格式不一样，正常人认为 Python 包的格式要嘛 是 egg，要嘛是whl 格式。

那么这个zip 是如何制作的呢，请看下面的示例。

```shell
[root@localhost ~]# ls -l demo
total 8
-rw-r--r-- 1 root root 30 May  8 19:27 calc.py
-rw-r--r-- 1 root root 35 May  8 19:33 __main__.py
[root@localhost ~]# 
[root@localhost ~]# cat demo/__main__.py
import calc

print(calc.add(2, 3))
[root@localhost ~]# 
[root@localhost ~]# cat demo/calc.py 
def add(x, y):
    return x+y
[root@localhost ~]# 
[root@localhost ~]# python -m zipfile -c demo.zip demo/*
[root@localhost ~]# 
```

制作完成后，我们可以执行用 python 去执行它

```shell
[root@localhost ~]# python demo.zip
5
[root@localhost ~]#
```



## 11. 默认参数最好不为可变对象

函数的参数分三种
- 可变参数
- 默认参数
- 关键字参数

这三者的具体区别，和使用方法在 廖雪峰的教程 里会详细的解释。这里就不搬运了。

今天要说的是，传递默认参数时，新手很容易踩雷的一个坑。

先来看一个示例
```
def func(item, item_list=[]):
    item_list.append(item)
    print(item_list)

func('iphone')
func('xiaomi', item_list=['oppo','vivo'])
func('huawei')
```
在这里，你可以暂停一下，思考一下会输出什么？

思考过后，你的答案是否和下面的一致呢
```
['iphone']
['oppo', 'vivo', 'xiaomi']
['iphone', 'huawei']
```

如果是，那你可以跳过这部分内容，如果不是，请接着往下看，这里来分析一下。

Python 中的 def 语句在每次执行的时候都初始化一个函数对象，这个函数对象就是我们要调用的函数，可以把它当成一个一般的对象，只不过这个对象拥有一个可执行的方法和部分属性。

对于参数中提供了初始值的参数，由于 Python 中的函数参数传递的是对象，也可以认为是传地址，在第一次初始化 def 的时候，会先生成这个可变对象的内存地址，然后将这个默认参数 item_list 会与这个内存地址绑定。在后面的函数调用中，如果调用方指定了新的默认值，就会将原来的默认值覆盖。如果调用方没有指定新的默认值，那就会使用原来的默认值。

![](http://image.python-online.cn/20190511165650.png)

## 12. 访问类中的私有方法

大家都知道，类中可供直接调用的方法，只有公有方法（protected类型的方法也可以，但是不建议）。也就是说，类的私有方法是无法直接调用的。

这里先看一下例子
```
class Kls():
    def public(self):
        print('Hello public world!')
        
    def __private(self):
        print('Hello private world!')
        
    def call_private(self):
        self.__private()

ins = Kls()

# 调用公有方法，没问题
ins.public()

# 直接调用私有方法，不行
ins.__private()

# 但你可以通过内部公有方法，进行代理
ins.call_private()
```

既然都是方法，那我们真的没有方法可以直接调用吗？

当然有啦，只是建议你千万不要这样弄，这里只是普及，让你了解一下。
```python
# 调用私有方法，以下两种等价
ins._Kls__private()
ins.call_private()
```

## 13. 时有时无的切片异常

这是个简单例子
```python
my_list = [1, 2, 3, 4, 5]
print(my_list[5])
```
执行一下，和我们预期的一样，会抛出索引异常。
```
Traceback (most recent call last):
  File "F:/Python Script/test.py", line 2, in <module>
    print(my_list[5])
IndexError: list index out of range
```

但是今天要说的肯定不是这个，而是一个你可能会不知道的冷知识。

来看看，如下这种写法就不会报索引异常，执行my_list[5:]，会返回一个新list：[]。
```python
my_list = [1, 2, 3]
print(my_list[5:])
```

## 14. 哪些情况下不需要续行符

在写代码时，为了代码的可读性，代码的排版是尤为重要的。

为了实现高可读性的代码，我们常常使用到的就是续行符 `\`。
```
>>> a = 'talk is cheap,'\
...     'show me the code.'
>>>
>>> print(a)
talk is cheap,show me the code.
```

那有哪些情况下，是不需要写续行符的呢？

经过总结，在这些符号中间的代码换行可以省略掉续行符：`[]`,`()`,`{}`

```
>>> my_list=[1,2,3,
...          4,5,6]

>>> my_tuple=(1,2,3,
...           4,5,6)

>>> my_dict={"name": "MING",
...          "gender": "male"}
```
另外还有，在多行文本注释中 `'''` ，续行符也是可以不写的。
```
>>> text = '''talk is cheap,
...           show me the code'''
```

## 15. 2.x 下 也可以使用 print(“”)

可能会有不少人，觉得只有 Python 3 才可以使用 print()，而 Python 2 只能使用print ""。

但是其实并不是这样的。

在Python 2.6之前，只支持
```python
print "hello"
```

在Python 2.6和2.7中，可以支持如下三种
```python
print "hello"
print("hello")
print ("hello")
```

在Python3.x中，可以支持如下两种
```python
print("hello")
print ("hello")
```

虽然 在 Python 2.6+ 可以和 Python3.x+ 一样，像函数一样去调用 print ，但是这仅用于两个 python 版本之间的代码兼容，并不是说在 python2.6+下使用 print() 后，就成了函数。

## 16. 迷一样的字符串

示例一

```python
# Python2.7
>>> a = "Hello_Python"
>>> id(a)
32045616
>>> id("Hello" + "_" + "Python")
32045616

# Python3.7
>>> a = "Hello_Python"
>>> id(a)
38764272
>>> id("Hello" + "_" + "Python")
32045616
```

示例二

```python
>>> a = "MING"
>>> b = "MING"
>>> a is b
True

# Python2.7
>>> a, b = "MING!", "MING!"
>>> a is b
True

# Python3.7
>>> a, b = "MING!", "MING!"
>>> a is b
False
```

示例三

```python
# Python2.7
>>> 'a' * 20 is 'aaaaaaaaaaaaaaaaaaaa'
True
>>> 'a' * 21 is 'aaaaaaaaaaaaaaaaaaaaa'
False

# Python3.7
>>> 'a' * 20 is 'aaaaaaaaaaaaaaaaaaaa'
True
>>> 'a' * 21 is 'aaaaaaaaaaaaaaaaaaaaa'
True
```



## 17. return不一定都是函数的终点

众所周知，try…finally… 的用法是：不管try里面是正常执行还是有报异常，最终都能保证finally能够执行。

同时我们又知道，一个函数里只要遇到 return 函数就会立马结束。

那问题就来了，以上这两种规则，如果同时存在，Python 解释器会如何选择？哪个优先级更高？

写个示例验证一下，就明白啦

```python
>>> def func():
...     try:
...         return 'try'
...     finally:
...         return 'finally'
...
>>> func()
'finally'
```

从输出中，我们可以发现：在try…finally…语句中，try中的 return 会被直接忽视（这里的 return 不是函数的终点），因为要保证 finally 能够执行。

**如果 try 里的 return 真的是直接被忽视吗？**

我们都知道如果一个函数没有 return，会隐式的返回 None，假设 try 里的 return 真的是直接被忽视，那当finally  下没有显式的 return 的时候，是不是会返回None呢？

还是写个 示例来验证一下：

```python
>>> def func():
...     try:
...         return 'try'
...     finally:
...         print('finally')
... 
>>> 
>>> func()
finally
'try'
>>> 
```

从结果来看，当 finally 下没有 reutrn ，其实 try 里的 return 仍然还是有效的。

那结论就出来了，如果 finally 里有显式的 return，那么这个 return 会直接覆盖 try 里的 return，而如果 finally 里没有 显式的 return，那么 try 里的 return 仍然有效。

## 18. 用户无感知的小整数池

为避免整数频繁申请和销毁内存空间，Python 定义了一个小整数池 [-5, 256] 这些整数对象是提前建立好的，不会被垃圾回收。

以上代码请在 终端Python环境下测试，如果你是在IDE中测试，由于 IDE 的影响，效果会有所不同。

```python
>>> a = -6
>>> b = -6
>>> a is b
False

>>> a = 256
>>> b = 256
>>> a is b
True

>>> a = 257
>>> b = 257
>>> a is b
False

>>> a = 257; b = 257
>>> a is b
True
```

**问题又来了：最后一个示例，为啥是True？**

因为当你在同一行里，同时给两个变量赋同一值时，解释器知道这个对象已经生成，那么它就会引用到同一个对象。如果分成两成的话，解释器并不知道这个对象已经存在了，就会重新申请内存存放这个对象。

## 19. 神奇的 intern 机制

字符串类型作为Python中最常用的数据类型之一，Python解释器为了提高字符串使用的效率和使用性能，做了很多优化.

例如：Python解释器中使用了 intern（字符串驻留）的技术来提高字符串效率，什么是intern机制？就是同样的字符串对象仅仅会保存一份，放在一个字符串储蓄池中，是共用的，当然，肯定不能改变，这也决定了字符串必须是不可变对象。

```
>>> s1="hello"
>>> s2="hello"
>>> s1 is s2
True

# 如果有空格，默认不启用intern机制
>>> s1="hell o"
>>> s2="hell o"
>>> s1 is s2
False

# 如果一个字符串长度超过20个字符，不启动intern机制
>>> s1 = "a" * 20
>>> s2 = "a" * 20
>>> s1 is s2
True

>>> s1 = "a" * 21
>>> s2 = "a" * 21
>>> s1 is s2
False

>>> s1 = "ab" * 10
>>> s2 = "ab" * 10
>>> s1 is s2
True

>>> s1 = "ab" * 11
>>> s2 = "ab" * 11
>>> s1 is s2
False
```



## 20. 反转字符串/列表最优雅的方式

反转序列并不难，但是如何做到最优雅呢？

先来看看，正常是如何反转的。

最简单的方法是使用列表自带的reverse()方法。

```python
>>> ml = [1,2,3,4,5]
>>> ml.reverse()
>>> ml
[5, 4, 3, 2, 1]
```

但如果你要处理的是字符串，reverse就无能为力了。你可以尝试将其转化成list，再reverse，然后再转化成str。转来转去，也太麻烦了吧？需要这么多行代码（后面三行是不能合并成一行的），一点都Pythonic。
```python
mstr1 = 'abc'
ml1 = list(mstr1)
ml1.reverse()
mstr2 = str(ml1)
```
对于字符串还有一种稍微复杂一点的，是自定义递归函数来实现。
```python
def my_reverse(str):
    if str == "":
        return str
    else:
        return my_reverse(str[1:]) + str[0]
```

在这里，介绍一种最优雅的反转方式，使用切片，不管你是字符串，还是列表，简直通杀。
```python
>>> mstr = 'abc'
>>> ml = [1,2,3]
>>> mstr[::-1]
'cba'
>>> ml[::-1]
[3, 2, 1]
```

## 21. 改变默认递归次数限制

上面才提到递归，大家都知道使用递归是有风险的，递归深度过深容易导致堆栈的溢出。如果你这字符串太长啦，使用递归方式反转，就会出现问题。

那到底，默认递归次数限制是多少呢？
```python
>>> import sys
>>> sys.getrecursionlimit()
1000
```

可以查，当然也可以自定义修改次数，退出即失效。
```python
>>> sys.setrecursionlimit(2000)
>>> sys.getrecursionlimit()
2000
```

## 22. 一行代码实现FTP服务器

搭建FTP，或者是搭建网络文件系统，这些方法都能够实现Linux的目录共享。但是FTP和网络文件系统的功能都过于强大，因此它们都有一些不够方便的地方。比如你想快速共享Linux系统的某个目录给整个项目团队，还想在一分钟内做到，怎么办？很简单，使用Python中的SimpleHTTPServer。

SimpleHTTPServer是Python 2自带的一个模块，是Python的Web服务器。它在Python 3已经合并到http.server模块中。具体例子如下，如不指定端口，则默认是8000端口。
```python
# python2
python -m SimpleHTTPServer 8888

# python3
python3 -m http.server 8888
```

![](http://image.python-online.cn/20190511165716.png)

SimpleHTTPServer有一个特性，如果待共享的目录下有index.html，那么index.html文件会被视为默认主页；如果不存在index.html文件，那么就会显示整个目录列表。

## 23. 让你晕头转向的 else 用法

if else 用法可以说最基础的语法表达式之一，但是今天不是讲这个的，一定要讲点不一样的。

if else 早已烂大街，但可能有很多人都不曾见过 for else 和 try else 的用法。为什么说它曾让我晕头转向，因为它不像 if else 那么直白，非黑即白，脑子经常要想一下才能才反应过来代码怎么走。反正我是这样的。

先来说说，for else
```python
def check_item(source_list, target):
    for item in source_list:
        if item == target:
            print("Exists!")
            break

    else:
        print("Does not exist")

```
在往下看之前，你可以思考一下，什么情况下才会走 else。是循环被 break，还是没有break？

给几个例子，你体会一下。
```python
check_item(["apple", "huawei", "oppo"], "oppo")
# Exists!

check_item(["apple", "huawei", "oppo"], "vivo")
# Does not exist
```
可以看出，没有被 break 的程序才会正常走else流程。

再来看看，try else 用法。
```python
def test_try_else(attr1 = None):
    try:
        if attr1:
            pass
        else:
            raise
    except:
        print("Exception occurred...")
    else:
        print("No Exception occurred...")
```

同样来几个例子。当不传参数时，就抛出异常。
```python
test_try_else()
# Exception occurred...

test_try_else("ming")
# No Exception occurred...
```

可以看出，没有 try 里面的代码块没有抛出异常的，会正常走else。

总结一下，for else 和 try else 相同，只要代码正常走下去不被 break，不抛出异常，就可以走else。


## 24. 字符串里的缝隙是什么？

在Python中求一个字符串里，某子字符（串）出现的次数。

大家都懂得使用  count() 函数，比如下面几个常规例子：

```python
>>> "aabb".count("a")
2
>>> "aabb".count("b")
2
>>> "aabb".count("ab")
1
```

但是如果我想计算空字符串的个数呢？
```python
>>> "aabb".count("")
5
```

**奇怪了吧？**

不是应该返回 0 吗？怎么会返回 5？

实际上，在 Python 看来，两个字符之间都是一个空字符，通俗的说就是缝隙。

因此 对于 `aabb` 这个字符串在 Python 来看应该是这样的

![](http://image.iswbm.com/20200509172331.png)

理解了这个“**缝隙**” 的概念后，以下这些就好理解了。

```python
>>> (" " * 10).count("")
11
>>> 
>>> "" in ""
True
>>> 
>>> "" in "M"
True
```



## 25. 正负得正，负负得正

从初中开始，我们就开始接触了`负数` ，并且都知道了`负负得正` 的思想。

Python 作为一门高级语言，它的编写符合人类的思维逻辑，包括 `负负得正` 。

```python
>>> 5-3
2
>>> 5--3
8
>>> 5+-3
2
>>> 5++3
8
>>> 5---3
2
```

## 26. 数值与字符串的比较

在 Python2 中，数字可以与字符串直接比较。结果是数值永远比字符串小。
```
>>> 100000000 < ""
True
>>> 100000000 < "ming"
True
```

但在 Python3 中，却不行。
```
>>> 100000000 < ""
TypeError: '<' not supported between instances of 'int' and 'str'
```

## 27. 循环中的局部变量泄露

在Python 2中x的值在一个循环执行之后被改变了。
```
# Python2
>>> x = 1
>>> [x for x in range(5)]
[0, 1, 2, 3, 4]
>>> x
4
```
不过在Python3 中这个问题已经得到解决了。
```
# Python3
>>> x = 1
>>> [x for x in range(5)]
[0, 1, 2, 3, 4]
>>> x
1
```

## 28. 字典居然是可以排序的？

字典不可排序的思想，似乎已经根深蒂固。

```python
# Python2.7.10
>>> mydict = {str(i):i for i in range(5)}
>>> mydict
{'1': 1, '0': 0, '3': 3, '2': 2, '4': 4}
```

假如哪一天，有人跟你说字典也可以是有序的，不要惊讶，这是真的。

在 Python3 中字典已经是有序的。

```python
# Python3.6.7
>>> mydict = {str(i):i for i in range(5)}
>>> mydict
{'0': 0, '1': 1, '2': 2, '3': 3, '4': 4}
```



## 29. 有趣但没啥用的 import 用法

import 是 Python 导包的方式。

你知道 Python 中内置了一些很有（wu）趣（liao）的包吗？

**Hello World**

```
>>> import __hello__
Hello World!
```

**Python之禅**

```
>>> import this

The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
```

**反地心引力漫画**

在 cmd 窗口中导入`antigravity`

```
>>> import antigravity
```

就会自动打开一个网页。
![](http://image.python-online.cn/20190511165735.png)

## 30. 局部/全局变量傻傻分不清

在开始讲之前，你可以试着运行一下下面这小段代码。

```
a = 1

def func01():
    a += 1
    
func01()

```

看似没有毛病，但实则已经犯了一个很基础的问题，这个报错相当常见吧？

```python
>>> func01()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in func01
UnboundLocalError: local variable 'a' referenced before assignment
```

回顾一下，什么是局部变量？在非全局下定义声明的变量都是局部变量。

当程序运行到 `a += 1` 时，Python 解释器就认为在函数内部要给 `a` 这个变量赋值，当然就把 `a` 当做局部变量了，报错是理所应当的。

理解了上面的例子，给你留个思考题。为什么下面的代码不会报错呢？

```
a = 1

def func02():
    print(a)
    
func02()
```

## 31. 字母也玩起了障眼法

以下我分别在 Python2.7 和 Python 3.7 的 console 模式下，运行了如下代码。

**在Python 2.x 中**

```
>>> valuе = 32
  File "<stdin>", line 1
    valuе = 32
        ^
SyntaxError: invalid syntax
```

**在Python 3.x 中**

```
>>> valuе = 32
>>> value
11
```

什么？没有截图你不信？

![](http://image.iswbm.com/20200509122954.png)



如果你在自己的电脑上尝试一下，结果可能是这样的

![](http://image.iswbm.com/20200509123107.png)



**怎么又好了呢？**

如果你想复现的话，请复制我这边给出的代码：`valuе = 32`



**这是为什么呢？**

原因在于，我上面使用的 value 变量名里的 `е` 又不是我们熟悉的 `e`，它是 Cyrillic（西里尔）字母。

```
>>> ord('е') # cyrillic 'e' (Ye)
1077
>>> ord('e') # latin 'e', as used in English and typed using standard keyboard
101
>>> 'е' == 'e'
False
```

细思恐极，在这里可千万不要得罪同事们，万一离职的时候，对方把你项目里的 `e` 全局替换成 `e`，到时候你就哭去吧，肉眼根本看不出来嘛。

## 32. 字符串的分割技巧

当我们对字符串进行分割时，且分割符是 `\n`，有可能会出现这样一个窘境：

```python
>>> str = "a\nb\n"
>>> print(str)
a
b

>>> str.split('\n')
['a', 'b', '']
>>>
```

会在最后一行多出一个元素，为了应对这种情况，你可以会多加一步处理。

但我想说的是，完成没有必要，对于这个场景，你可以使用 `splitlines`

```python
>>> str.splitlines()
['a', 'b']
```



## 33. 嵌套上下文管理的另类写法

当我们要写一个嵌套的上下文管理器时，可能会这样写

```python
import contextlib

@contextlib.contextmanager
def test_context(name):
    print('enter, my name is {}'.format(name))

    yield

    print('exit, my name is {}'.format(name))

with test_context('aaa'):
    with test_context('bbb'):
        print('========== in main ============')
```

输出结果如下

```python
enter, my name is aaa
enter, my name is bbb
========== in main ============
exit, my name is bbb
exit, my name is aaa
```

除此之外，你可知道，还有另一种嵌套写法

```python
with test_context('aaa'), test_context('bbb'):
    print('========== in main ============')
```

## 34. += 不等同于=+

对列表 进行`+=` 操作相当于 extend，而使用 `=+` 操作是新增了一个列表。

因此会有如下两者的差异。

```python
# =+
>>> a = [1, 2, 3, 4]
>>> b = a
>>> a = a + [5, 6, 7, 8]
>>> a
[1, 2, 3, 4, 5, 6, 7, 8]
>>> b
[1, 2, 3, 4]


# += 
>>> a = [1, 2, 3, 4]
>>> b = a
>>> a += [5, 6, 7, 8]
>>> a
[1, 2, 3, 4, 5, 6, 7, 8]
>>> b
[1, 2, 3, 4, 5, 6, 7, 8]
```

## 35. 增量赋值的性能更好

诸如 `+=` 和 `*=` 这些运算符，叫做 增量赋值运算符。

这里使用用 += 举例，以下两种写法，在效果上是等价的。

```
# 第一种
a = 1 ; a += 1

# 第二种
a = 1; a = a + 1
```

`+=` 其背后使用的魔法方法是 \__iadd__，如果没有实现这个方法则会退而求其次，使用 \__add__ 。

这两种写法有什么区别呢？

用列表举例 a += b，使用 \__add__ 的话就像是使用了a.extend(b),如果使用 \__add__ 的话，则是 a = a+b,前者是直接在原列表上进行扩展，而后者是先从原列表中取出值，在一个新的列表中进行扩展，然后再将新的列表对象返回给变量，显然后者的消耗要大些。

所以在能使用增量赋值的时候尽量使用它。

## 36. x == +x 吗？

在大多数情况下，这个等式是成立的。

```
>>> n1 = 10086
>>> n2 = +n1
>>>
>>> n1 == n2
True
```

什么情况下，这个等式会不成立呢？

由于Counter的机制，`+` 用于两个 Counter 实例相加，而相加的结果如果元素的个数 `<=` 0，就会被丢弃。

```
>>> from collections import Counter
>>> ct = Counter('abcdbcaa')
>>> ct
Counter({'a': 3, 'b': 2, 'c': 2, 'd': 1})
>>> ct['c'] = 0
>>> ct['d'] = -2
>>>
>>> ct
Counter({'a': 3, 'b': 2, 'c': 0, 'd': -2})
>>>
>>> +ct
Counter({'a': 3, 'b': 2})
```



## 37.  如何将 print 内容输出到文件

Python 3 中的 print 作为一个函数，由于可以接收更多的参数，所以功能变为更加强大。

比如今天要说的使用 print 将你要打印的内容，输出到日志文件中（但是我并不推荐使用它）。

```python
>>> with open('test.log', mode='w') as f:
...     print('hello, python', file=f, flush=True)
>>> exit()

$ cat test.log
hello, python
```



## 38. site-packages和 dist-packages

如果你足够细心，你会在你的机器上，有些包是安装在 **site-packages** 下，而有些包安装在 **dist-packages** 下。

**它们有什么区别呢？**

一般情况下，你只见过 site-packages 这个目录，而你所安装的包也将安装在 这个目录下。

而 dist-packages 其实是 debian 系的 Linux 系统（如 Ubuntu）才特有的目录，当你使用 apt 去安装的 Python 包会使用 dist-packages，而你使用 pip 或者 easy_install 安装的包还是照常安装在 site-packages 下。

Debian 这么设计的原因，是为了减少不同来源的 Python 之间产生的冲突。

如何查找 Python 安装目录

```python
>>> from distutils.sysconfig import get_python_lib
>>> print(get_python_lib())
/usr/lib/python2.7/site-packages
```



## 39. argument 和 parameter 的区别

arguments 和 parameter 的翻译都是参数，在中文场景下，二者混用基本没有问题，毕竟都叫参数嘛。

但若要严格再进行区分，它们实际上还有各自的叫法

- parameter：形参（**formal parameter**），体现在函数内部，作用域是这个函数体。
- argument ：实参（**actual parameter**），调用函数实际传递的参数。

举个例子，如下这段代码，`"error"` 为 argument，而 msg 为 `parameter`。

```python
def output_msg(msg):
	print(msg)
	
output_msg("error")
```

## 40.  简洁而优雅的链式比较

先给看一个示例

```
>>> False == False == True
False
```

你知道这个表达式会返回 False 吗？

我再给你举个例子，你可能就懂了。

```
f 18 < age < 60:
    print("young man")
```

如果还不明白，再给你整个等价写法。

```
>>> False == False and False == True
False
```





## 附录：参考文章 

- [wtfpython](https://github.com/satwikkansal/wtfpython)

---

![关注公众号，获取最新干货！](http://image.python-online.cn/image-20200320125724880.png)
